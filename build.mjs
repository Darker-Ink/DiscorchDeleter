import esbuild from 'esbuild';
import fs from 'fs/promises';
import path from 'path';

const configFile = 'tampermonkey.config.json';
const srcDir = 'src';
const outDir = 'dist';

const mainEntryPoint = path.join(srcDir, 'index.ts');
const preloadEntryPoint = path.join(srcDir, 'preload.ts');
const tempEntryFile = path.join(srcDir, '_temp_entry.ts');

/**
 * Minifies CSS
 * @param {string} css - The CSS to minify
 * @returns {string} The minified CSS
 */
const minifyCSS = (css) => {
  return css
    .replace(/\/\*(?:(?!\*\/)[\s\S])*\*\/|[\r\n\t]+/g, '')
    .replace(/\s{2,}/g, ' ')
    .replace(/\s*([{:}])\s*/g, '$1')
    .replace(/;}/g, '}')
    .trim();
}

/**
 * Minifies HTML
 * @param {string} html - The HTML to minify
 * @returns {string} The minified HTML
 */
const minifyHTML = (html) => {
  return html
    .replace(/<!--(?:(?!-->)[\s\S])*-->/g, '')
    .replace(/\s{2,}/g, ' ')
    .replace(/>\s+</g, '><')
    .replace(/^\s+|\s+$/gm, '')
    .trim();
}

const tampermonkeyAssetImporterPlugin = {
  name: 'tampermonkey-asset-importer',
  setup(build) {
    build.onResolve({ filter: /\.css$/ }, args => {
      if (args.path.startsWith('.')) {
        return {
          path: path.resolve(args.resolveDir, args.path),
          namespace: 'css-file',
        };
      }
      return {
        path: args.path,
        namespace: 'css-file',
      };
    });

    build.onLoad({ filter: /.*/, namespace: 'css-file' }, async (args) => {
      try {
        const cssContent = await fs.readFile(args.path, 'utf8');
        const minifiedCss = minifyCSS(cssContent);
        const escapedCssContent = minifiedCss
          .replace(/\\/g, '\\\\')
          .replace(/`/g, '\\`')
          .replace(/\$/g, '\\$');
        const randomId = Math.floor(Math.random() * 50000);
        
        const contents = `
          (function() {
            console.log('Injecting styles from ${args.path}');
            var GM_STYLE${randomId} = \`${escapedCssContent}\`;
            if (typeof GM_addStyle !== 'undefined') {
              GM_addStyle(GM_STYLE${randomId});
            } else {
              console.warn('[Tampermonkey Asset Importer] GM_addStyle is not defined. Cannot inject styles from ${args.path}');
              const styleElement = document.createElement('style');
              styleElement.textContent = GM_STYLE${randomId};
              (document.head || document.documentElement).appendChild(styleElement);
            }
          })();
        `;
        return {
          contents: contents,
          loader: 'js',
          resolveDir: path.dirname(args.path)
        };
      } catch (error) {
        console.error(`Error reading or processing CSS file ${args.path}:`, error);
        return {
          errors: [{ text: `Could not process CSS file ${args.path}` }],
        };
      }
    });

    build.onResolve({ filter: /\.html$/ }, args => {
      if (args.path.startsWith('.')) {
        return {
          path: path.resolve(args.resolveDir, args.path),
          namespace: 'html-file',
        };
      }
      return {
        path: args.path,
        namespace: 'html-file',
      };
    });

    build.onLoad({ filter: /.*/, namespace: 'html-file' }, async (args) => {
      try {
        const htmlContent = await fs.readFile(args.path, 'utf8');
        const minifiedHtml = minifyHTML(htmlContent);
        const escapedHtmlContent = minifiedHtml
          .replace(/\\/g, '\\\\')
          .replace(/`/g, '\\`')
          .replace(/\$/g, '\\$');

        return {
          contents: `export default \`${escapedHtmlContent}\`;`,
          loader: 'js',
          resolveDir: path.dirname(args.path)
        };
      } catch (error) {
        console.error(`Error reading or processing HTML file ${args.path}:`, error);
        return {
          errors: [{ text: `Could not process HTML file ${args.path}` }],
        };
      }
    });
  },
};

/**
 * Checks if a file exists
 * @param {string} filePath - The path to the file
 * @returns {boolean} True if the file exists, false otherwise
 */
const fileExists = async (filePath) => {
  try {
    await fs.access(filePath);
    return true;
  } catch {
    return false;
  }
}

/**
 * Build script
 */
const buildScript = async () => {
  let currentEntryPoint = mainEntryPoint;
  let createdTempEntry = false;

  try {
    const hasPreload = await fileExists(preloadEntryPoint);

    if (hasPreload) {
      const tempEntryContent = `// Temporary entry file generated by build.mjs
import './preload.ts';
import './index.ts';
`;
      await fs.writeFile(tempEntryFile, tempEntryContent);
      currentEntryPoint = tempEntryFile;
      createdTempEntry = true;
    }

    const configContent = await fs.readFile(configFile, 'utf-8');
    const config = JSON.parse(configContent);

    let metadata = '// ==UserScript==\n';
    for (const key in config) {
      if (Array.isArray(config[key])) {
        config[key].forEach(value => {
          metadata += `// @${key.padEnd(12)} ${value}\n`;
        });
      } else {
        metadata += `// @${key.padEnd(12)} ${config[key]}\n`;
      }
    }
    metadata += '// ==/UserScript==\n\n';

    await fs.mkdir(outDir, { recursive: true });

    const scriptName = config.name.toLowerCase().replace(/\s+/g, '-') + '.user.js';
    const outFile = path.join(outDir, scriptName);

    const result = await esbuild.build({
      entryPoints: [currentEntryPoint],
      bundle: true,
      outfile: outFile,
      platform: 'browser',
      format: 'esm',
      charset: 'utf8',
      banner: {
        js: metadata + '\n(async () => {\n"use strict";\n',
      },
      footer: {
        js: '\n})();',
      },
      plugins: [tampermonkeyAssetImporterPlugin],
      minify: true,
      treeShaking: true,
    });

    console.log(`Successfully built ${outFile}`);

    if (result.warnings.length > 0) {
      console.warn('Build warnings:', result.warnings);
    }

  } catch (error) {
    console.error('Build failed:', error);
    process.exitCode = 1;
  } finally {
    if (createdTempEntry) {
      try {
        await fs.unlink(tempEntryFile);
      } catch (unlinkError) {
        console.error('Failed to delete temporary entry file:', unlinkError);
      }
    }
  }
}

/**
 * Watch for changes
 */
const watch = async () => {
    console.log('Watching for changes...');
    const pathsToWatch = [srcDir, configFile];
    
    await buildScript();

    let buildTimeout;
    for (const item of pathsToWatch) {
        fs.watch(item, { recursive: true }, (eventType, filename) => {
            if (filename) {
                console.log(`Detected ${eventType} in ${path.join(item, filename)}. Rebuilding in 250ms...`);
                clearTimeout(buildTimeout);
                buildTimeout = setTimeout(async () => {
                    await buildScript();
                }, 250);
            }
        });
    }
}

if (process.argv.includes('--watch')) {
    watch();
} else {
    buildScript();
} 